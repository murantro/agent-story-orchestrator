# Copyright 2026 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Interaction engine - autonomous NPC-to-NPC interactions each tick.

Each tick, NPCs in the same location may interact based on their
intention vectors, existing relationships, and energy. Interactions
produce WorldEvents (which propagate and form memories) and
relationship deltas (applied by RelationshipEngine).

All math is pure numpy - no LLM calls.
"""

from __future__ import annotations

from collections import defaultdict
from dataclasses import dataclass, field

import numpy as np

from app.config import (
    CONFLICT_ENERGY_COST,
    CONFLICT_HEALTH_DAMAGE,
    INTERACTION_ENERGY_COST,
    INTERACTION_RATE,
    INTIMIDATION_HEALTH_DAMAGE,
    MAX_INTERACTIONS_PER_LOCATION,
    MIN_ENERGY_FOR_INTERACTION,
)
from app.models.events import LocalityScale, WorldEvent
from app.models.npc_status import (
    INTENTION_DIM,
    SOCIAL_INFLUENCE_DIM,
    NPCVectorialStatus,
)

# --- Interaction type definitions ---

# Maps (dominant_a, dominant_b) -> interaction_type.
# Order-independent: both (a,b) and (b,a) are checked.
_INTERACTION_TYPE_MAP: dict[tuple[str, str], str] = {
    ("socialize", "socialize"): "friendly_chat",
    ("socialize", "nurture"): "bonding",
    ("dominate", "survive"): "intimidation",
    ("dominate", "escape"): "intimidation",
    ("dominate", "dominate"): "conflict",
    ("achieve", "achieve"): "competition",
    ("nurture", "survive"): "aid",
    ("explore", "explore"): "shared_discovery",
    ("create", "create"): "collaboration",
    ("create", "achieve"): "mentorship",
}

# Fallback for intention pairs not in the map.
_DEFAULT_INTERACTION = "casual_encounter"


@dataclass
class InteractionOutcome:
    """Result of resolving one NPC-NPC interaction.

    Attributes:
        npc_a_id: First participant.
        npc_b_id: Second participant.
        interaction_type: Category of the interaction.
        event: WorldEvent generated by this interaction.
        relationship_delta: How much the affinity changes (symmetric).
        energy_cost: Energy deducted from both participants.
        health_delta_a: Health change for NPC A (negative = damage).
        health_delta_b: Health change for NPC B (negative = damage).
    """

    npc_a_id: str
    npc_b_id: str
    interaction_type: str
    event: WorldEvent
    relationship_delta: float
    energy_cost: float = 0.0
    health_delta_a: float = 0.0
    health_delta_b: float = 0.0


# --- Emotion impact templates per interaction type ---
# Index: joy, sadness, anger, fear, surprise, disgust, trust, anticipation

_EMOTION_TEMPLATES: dict[str, np.ndarray] = {
    "friendly_chat": np.array(
        [0.15, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1, 0.0], dtype=np.float32
    ),
    "bonding": np.array([0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.15, 0.0], dtype=np.float32),
    "intimidation": np.array(
        [0.0, 0.0, 0.15, 0.2, 0.0, 0.0, -0.1, 0.0], dtype=np.float32
    ),
    "conflict": np.array(
        [0.0, 0.0, 0.25, 0.15, 0.0, 0.0, -0.15, 0.0], dtype=np.float32
    ),
    "competition": np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2], dtype=np.float32),
    "aid": np.array([0.15, 0.0, 0.0, -0.1, 0.0, 0.0, 0.2, 0.0], dtype=np.float32),
    "shared_discovery": np.array(
        [0.0, 0.0, 0.0, 0.0, 0.15, 0.0, 0.0, 0.15], dtype=np.float32
    ),
    "collaboration": np.array(
        [0.15, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1, 0.15], dtype=np.float32
    ),
    "mentorship": np.array([0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.15, 0.1], dtype=np.float32),
    "casual_encounter": np.array(
        [0.02, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02, 0.0], dtype=np.float32
    ),
}

_RELATIONSHIP_DELTAS: dict[str, float] = {
    "friendly_chat": 0.1,
    "bonding": 0.15,
    "intimidation": -0.15,
    "conflict": -0.2,
    "competition": 0.0,  # Could go either way; resolved by personality
    "aid": 0.2,
    "shared_discovery": 0.1,
    "collaboration": 0.15,
    "mentorship": 0.1,
    "casual_encounter": 0.02,
}

# Energy cost per interaction type (deducted from both participants).
_ENERGY_COSTS: dict[str, float] = {
    "friendly_chat": INTERACTION_ENERGY_COST,
    "bonding": INTERACTION_ENERGY_COST,
    "intimidation": CONFLICT_ENERGY_COST,
    "conflict": CONFLICT_ENERGY_COST,
    "competition": INTERACTION_ENERGY_COST * 2,
    "aid": INTERACTION_ENERGY_COST,
    "shared_discovery": INTERACTION_ENERGY_COST,
    "collaboration": INTERACTION_ENERGY_COST,
    "mentorship": INTERACTION_ENERGY_COST,
    "casual_encounter": INTERACTION_ENERGY_COST * 0.5,
}

# Health damage per interaction type.
# Tuple: (damage_to_a, damage_to_b). Negative = damage.
_HEALTH_IMPACTS: dict[str, tuple[float, float]] = {
    "conflict": (-CONFLICT_HEALTH_DAMAGE, -CONFLICT_HEALTH_DAMAGE),
    "intimidation": (0.0, -INTIMIDATION_HEALTH_DAMAGE),
    "aid": (0.0, 0.05),  # Aid heals the recipient slightly
}

_DESCRIPTION_TEMPLATES: dict[str, str] = {
    "friendly_chat": "{a} and {b} had a friendly conversation",
    "bonding": "{a} and {b} shared a bonding moment",
    "intimidation": "{a} intimidated {b}",
    "conflict": "{a} and {b} got into a conflict",
    "competition": "{a} and {b} competed with each other",
    "aid": "{a} helped {b}",
    "shared_discovery": "{a} and {b} explored something together",
    "collaboration": "{a} and {b} collaborated on something creative",
    "mentorship": "{a} mentored {b}",
    "casual_encounter": "{a} and {b} crossed paths briefly",
}


def _sigmoid(x: float) -> float:
    """Numerically stable sigmoid."""
    if x >= 0:
        return 1.0 / (1.0 + np.exp(-x))
    exp_x = np.exp(x)
    return float(exp_x / (1.0 + exp_x))


# Compatibility matrix: how well intention pairs align for interaction.
# High values along diagonal = same intentions attract interaction.
# Computed as identity + small off-diagonal bonuses for complementary pairs.
_COMPAT_MATRIX = np.eye(INTENTION_DIM, dtype=np.float32) * 0.5
# socialize (1) <-> nurture (6) bonus
_COMPAT_MATRIX[1, 6] = 0.3
_COMPAT_MATRIX[6, 1] = 0.3
# create (4) <-> achieve (2) bonus
_COMPAT_MATRIX[4, 2] = 0.2
_COMPAT_MATRIX[2, 4] = 0.2
# dominate (5) <-> survive (0) generates interaction (intimidation)
_COMPAT_MATRIX[5, 0] = 0.3
_COMPAT_MATRIX[0, 5] = 0.3


@dataclass
class InteractionEngine:
    """Resolves autonomous NPC interactions per tick.

    Args:
        interaction_rate: Base probability multiplier.
        max_per_location: Maximum interactions per location per tick.
        min_energy: Minimum energy threshold for participation.
    """

    interaction_rate: float = INTERACTION_RATE
    max_per_location: int = MAX_INTERACTIONS_PER_LOCATION
    min_energy: float = MIN_ENERGY_FOR_INTERACTION
    _rng: np.random.Generator = field(default_factory=lambda: np.random.default_rng())

    def resolve_interaction_type(
        self,
        npc_a: NPCVectorialStatus,
        npc_b: NPCVectorialStatus,
    ) -> str:
        """Determine interaction type from the dominant intentions of both NPCs.

        Args:
            npc_a: First NPC.
            npc_b: Second NPC.

        Returns:
            Interaction type string.
        """
        dom_a = npc_a.dominant_intention()
        dom_b = npc_b.dominant_intention()
        # Check both orderings since the map is order-dependent for some types
        itype = _INTERACTION_TYPE_MAP.get(
            (dom_a, dom_b),
            _INTERACTION_TYPE_MAP.get((dom_b, dom_a), _DEFAULT_INTERACTION),
        )
        return itype

    def compute_interaction_probability(
        self,
        npc_a: NPCVectorialStatus,
        npc_b: NPCVectorialStatus,
    ) -> float:
        """Compute probability that two NPCs interact this tick.

        Args:
            npc_a: First NPC.
            npc_b: Second NPC.

        Returns:
            Probability in [0, 1].
        """
        if npc_a.energy < self.min_energy or npc_b.energy < self.min_energy:
            return 0.0

        # Intention compatibility via compatibility matrix
        compat = float(npc_a.intention @ _COMPAT_MATRIX @ npc_b.intention)
        # Relationship bonus
        rel_bonus = npc_a.relationships.get(npc_b.npc_id, 0.0) * 0.2
        # Energy factor
        energy_factor = min(npc_a.energy, npc_b.energy)
        # Final probability
        prob = _sigmoid(compat + rel_bonus) * energy_factor * self.interaction_rate
        return float(np.clip(prob, 0.0, 1.0))

    def resolve(
        self,
        npc_a: NPCVectorialStatus,
        npc_b: NPCVectorialStatus,
        game_time: float,
    ) -> InteractionOutcome:
        """Resolve a single interaction between two NPCs.

        Args:
            npc_a: First NPC.
            npc_b: Second NPC.
            game_time: Current in-game time for the generated event.

        Returns:
            InteractionOutcome with event and relationship delta.
        """
        itype = self.resolve_interaction_type(npc_a, npc_b)
        emotion_impact = _EMOTION_TEMPLATES.get(
            itype,
            _EMOTION_TEMPLATES["casual_encounter"],
        ).copy()
        rel_delta = _RELATIONSHIP_DELTAS.get(itype, 0.02)

        # For competition, personality compatibility decides sign
        if itype == "competition":
            # Compatible personalities enjoy competition; incompatible resent it
            diff = npc_a.personality - npc_b.personality
            distance = float(np.linalg.norm(diff))
            max_dist = float(np.sqrt(len(npc_a.personality)))
            compat = 1.0 - 2.0 * (distance / max_dist)
            rel_delta = 0.05 if compat > 0.0 else -0.05

        desc_template = _DESCRIPTION_TEMPLATES.get(
            itype,
            "{a} and {b} interacted",
        )
        description = desc_template.format(a=npc_a.name, b=npc_b.name)

        event = WorldEvent(
            source_npc_id=npc_a.npc_id,
            event_type=f"interaction_{itype}",
            description=description,
            origin_scale=LocalityScale.PERSONAL,
            current_scale=LocalityScale.PERSONAL,
            location_id=npc_a.location_id,
            timestamp=game_time,
            intensity=0.3,
            emotion_impact=emotion_impact,
            social_impact=np.zeros(SOCIAL_INFLUENCE_DIM, dtype=np.float32),
        )

        energy_cost = _ENERGY_COSTS.get(itype, INTERACTION_ENERGY_COST)
        health_a, health_b = _HEALTH_IMPACTS.get(itype, (0.0, 0.0))

        return InteractionOutcome(
            npc_a_id=npc_a.npc_id,
            npc_b_id=npc_b.npc_id,
            interaction_type=itype,
            event=event,
            relationship_delta=rel_delta,
            energy_cost=energy_cost,
            health_delta_a=health_a,
            health_delta_b=health_b,
        )

    def tick(
        self,
        npcs: list[NPCVectorialStatus],
        game_time: float,
    ) -> list[InteractionOutcome]:
        """Resolve all autonomous interactions for one tick.

        Groups NPCs by location, computes pairwise probabilities,
        and stochastically selects interactions up to the cap.

        Args:
            npcs: All NPCs in the world.
            game_time: Current in-game time.

        Returns:
            List of interaction outcomes.
        """
        # Group by location
        by_location: dict[str, list[NPCVectorialStatus]] = defaultdict(list)
        for npc in npcs:
            if npc.energy >= self.min_energy:
                by_location[npc.location_id].append(npc)

        outcomes: list[InteractionOutcome] = []

        for _loc_id, loc_npcs in by_location.items():
            if len(loc_npcs) < 2:
                continue

            loc_outcomes: list[InteractionOutcome] = []
            # Track NPCs that already interacted this tick
            interacted: set[str] = set()

            for i in range(len(loc_npcs)):
                for j in range(i + 1, len(loc_npcs)):
                    if len(loc_outcomes) >= self.max_per_location:
                        break
                    a, b = loc_npcs[i], loc_npcs[j]
                    # Each NPC can interact at most once per tick
                    if a.npc_id in interacted or b.npc_id in interacted:
                        continue
                    prob = self.compute_interaction_probability(a, b)
                    if self._rng.random() < prob:
                        outcome = self.resolve(a, b, game_time)
                        loc_outcomes.append(outcome)
                        interacted.add(a.npc_id)
                        interacted.add(b.npc_id)
                if len(loc_outcomes) >= self.max_per_location:
                    break

            outcomes.extend(loc_outcomes)

        return outcomes
